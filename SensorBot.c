#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    zoom,           sensorAccelerometer)
#pragma config(Sensor, dgtl1,  Eye1,           sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  Eye2,           sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  Eye3,           sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  Eye4,           sensorNone)
#pragma config(Sensor, dgtl11, Eye5,           sensorNone)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           RF,            tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LR,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Spinner,       tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           LF,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          RR,            tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define HISTORY 5
#define ENCODER_RANGE 300
#define SCAN_RANGE 250

#define SAFE 30
#define BUMP 30

// High-pass filter
// y[t] = alpha * (y[t-1] + x[t] - x[t-1])

struct HPF {
  float x;
  float y;
  float alpha;
};

void HPFinit(HPF* hpf, float alpha) {
  hpf->x = 0.0;
  hpf->y = 0.0;
  hpf->alpha = alpha;
}

float HPFupdate(HPF* hpf, float x) {
  hpf->y = hpf->alpha * (hpf->y + x - hpf->x);
  hpf->x = x;

  return hpf->y;
}

enum Direction {
	DIR_E = 0,  // 0 deg
	DIR_NE = 1,
	DIR_N = 2,
	DIR_NW = 3,
	DIR_W = 4,  // 180 deg
	DIR_SW = 5,
	DIR_S = 6,
	DIR_SE = 7,

	DIRECTIONS = 8,
};

// Maintains the median value of a stream of distances.
struct MedianFilter {
	int last;

	int distance[HISTORY];  // ordered distances
	int index[HISTORY];     // time of distance in position p
	int position[HISTORY];  // position of distance at time t
};

// Tracks median distances in the 8 directions
struct World {
	MedianFilter dir[DIRECTIONS];
};

void initialize(World* w) {
	for (int d = 0; d < (long)DIRECTIONS; d++) {
		MedianFilter* o = &w->dir[(Direction)d];
    o->last = 0;
    for (int i = 0; i < HISTORY; i++) {
      o->distance[i] = 100;
      o->index[i] = i;
      o->position[i] = i;
    }
}
}

void swap(MedianFilter* o, int p, int k) {
	int tmp;

	tmp = o->distance[p];
	o->distance[p] = o->distance[k];
	o->distance[k] = tmp;

	int tp = o->index[p];
	int tk = o->index[k];

	o->index[p] = tk;
	o->index[k] = tp;

	tmp = o->position[tp];
	o->position[tp] = o->position[tk];
	o->position[tk] = tmp;
}

void update(World* w, Direction direction, int distance) {
	if (distance <= 0) return;

	MedianFilter* o = &(w->dir[direction]);

	int p = o->position[o->last];  // insertion point
	o->distance[p] = distance;
	if (p < HISTORY - 1 && distance > o->distance[p + 1]) {
		while (p < HISTORY - 1 && distance > o->distance[p + 1]) {
			swap(o, p, p + 1);
		}
	}
	if (p > 0 && distance < o->distance[p - 1]) {
		while (p > 0 && distance < o->distance[p - 1]) {
			swap(o, p, p - 1);
		}
	}
	o->last = (o->last + 1) % HISTORY;
}

int getDistance(World* w, Direction direction) {
	return w->dir[direction].distance[HISTORY / 2];
}

Direction angleToDir(int angle) {
	angle = (angle + 22) % 360;

  return (Direction)(angle / 45);
}


int correct(int distance, Direction dir) {
  switch (dir) {
    case DIR_E:
      return distance;

    case DIR_N:
    case DIR_S:
      return distance - 10;

    case DIR_NE:
    case DIR_SE:
      return distance - 10;

    default:
      return distance;
  }
}

int getCorrected(World* w, Direction dir) {
  return correct(getDistance(w, dir), dir);
}

int minDistance(World *w, Direction* dirs, int count) {
	int result = 999;
  for (int i = 0; i < count; i++) {
  	int d = getCorrected(w, dirs[i]);
  	if (d < result) result = d;
  }
  return result;
}

int maxDistance(World *w, Direction* dirs, int count) {
	int result = 0;
  for (int i = 0; i < count; i++) {
  	int d = getCorrected(w, dirs[i]);
  	if (d > result) result = d;
  }
  return result;
}

World w;
bool hit = false;

task displayMap() {
	Direction front[3] = {DIR_E, DIR_NE, DIR_SE};

	while (true) {
		writeDebugStreamLine("| %.03d | %.03d | %.03d |", getCorrected(&w, DIR_NW), getCorrected(&w, DIR_N), getCorrected(&w, DIR_NE));
		writeDebugStreamLine("| %.03d |     | %.03d |", getCorrected(&w, DIR_W),  getCorrected(&w, DIR_E));
		writeDebugStreamLine("| %.03d | %.03d | %.03d |", getCorrected(&w, DIR_SW), getCorrected(&w, DIR_S), getCorrected(&w, DIR_SE));
		writeDebugStreamLine("");
    writeDebugStreamLine("%d %d", maxDistance(&w, front, 3), minDistance(&w, front, 3));
  	wait1Msec(1000);
  }
}

task measure() {
	initialize(&w);
	nMotorEncoder[Spinner] = 0;

	int last_angle = -1000;  // ensure we read the first values

	int sign = +1;
  HPF bumper;
  HPFinit(&bumper, 0.05);
  int hittime = time1[T4];

	while (true) {
		int acc = HPFupdate(&bumper, SensorValue[zoom]);
    if (abs(acc) > BUMP) {
    	hit = true;
    	hittime = time1[T4];
		  writeDebugStreamLine("HIT=%d", acc);
	  }
	  if (time1[T4] > hittime + 1000) {
	  	hit = false;
	  }

  	motor[Spinner] = 40 * sign;

		// encoder will cover +/- ENCODER_RANGE, which we map
	  // to 0 - 360 degrees.
		int encoder = nMotorEncoder[Spinner];
    if ((sign < 0 && encoder > +SCAN_RANGE) ||
    	  (sign > 0 && encoder < -SCAN_RANGE)) sign = -sign;

		int angle = ( 360 * encoder / (2 * ENCODER_RANGE)) % 360;
		if (angle < 0) angle += 360;

		if (abs(last_angle - angle) < 8) {
		  wait1Msec(1);
		  continue;
	  }
    last_angle = angle;

		// Eye1 -> 0 degrees
		// Eye2 -> 120
		// Eye3 -> 240
		update(&w, angleToDir(angle + 0),   SensorValue[Eye1]);
		update(&w, angleToDir(angle + 120), SensorValue[Eye2]);
		update(&w, angleToDir(angle + 240), SensorValue[Eye3]);
	}
}

void drive(int left, int right) {
  motor[LF] = left;
  motor[LR] = left;
  motor[RF] = right;
  motor[RR] = right;
}

enum State {
  STATE_FORWARD = 0,
  STATE_TURN_LEFT = 1,
  STATE_TURN_RIGHT = 2,
  STATE_BACK_OUT = 3,
};


task main()
{
	wait(2);  // initialize the accelerometer

	startTask(measure);
	startTask(displayMap);

  Direction front[3] = {DIR_E, DIR_NE, DIR_SE};
  Direction left[2] = {DIR_N, DIR_NE};
  Direction right[2] = {DIR_S, DIR_SE};

	int fwd_start = time1[T3];
  State s = STATE_FORWARD;
  int space;
  while (true) {
    switch (s) {
      case STATE_FORWARD:
        if (hit && time1[T3] > fwd_start + 1000) s = STATE_BACK_OUT;
        drive(120, 120);
        if (minDistance(&w, front, 3) < SAFE) {
        	 s = minDistance(&w, left, 2) > minDistance(&w, right, 2)
        	     ? STATE_TURN_LEFT : STATE_TURN_RIGHT;
        	 writeDebugStreamLine("FORWARD -> %d", s);
        }
        break;
      case STATE_TURN_LEFT:
        drive(-50, +50);
        space = minDistance(&w, front, 3);
        if (space > SAFE + 10) {
          s = STATE_FORWARD;
        	writeDebugStreamLine("LEFT -> FWD %d", space);
          fwd_start = time1[T3];
        } else {
          if (hit) {
          	s = STATE_BACK_OUT;
        	  writeDebugStreamLine("LEFT -> OUT");
          }
        }
        break;
      case STATE_TURN_RIGHT:
        drive(+50, -50);
        space = minDistance(&w, front, 3);
        if (space > SAFE + 10) {
          s = STATE_FORWARD;
        	writeDebugStreamLine("RIGHT -> FWD %d", space);
          fwd_start = time1[T3];
        } else {
          if (hit) {
          	s = STATE_BACK_OUT;
        	  writeDebugStreamLine("RIGHT -> FWD");
          }
        }
        break;
      case STATE_BACK_OUT:
        drive(-30, -30);
        wait1Msec(1000);
        int turn = minDistance(&w, left, 2) > minDistance(&w, right, 2) ? -40 : 40;
        drive(turn, -turn);
        wait1Msec(1000);
        s = STATE_FORWARD;
     	  writeDebugStreamLine("OUT -> FWD");
        fwd_start = time1[T3];
        break;
    }
  }
}
