#pragma config(Sensor, dgtl1,  RightSide,      sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  enc,            sensorRotation)
#pragma config(Sensor, dgtl5,  LeftSide,       sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  BottomRear,     sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  FrontRight,     sensorSONAR_cm)
#pragma config(Sensor, dgtl11, FrontLeft,      sensorSONAR_cm)
#pragma config(Motor,  port1,           LR,            tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           RF,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RR,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LF,            tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

enum State {
  FORWARD = 0,
  ROTATE = 1,
};

State state = FORWARD;

int front_distance = 0;
int left_distance = 0;

int front_sum = 0;
int left_sum = 0;
int count = 0;

task display() {
	while (true) {
		if (time1[timer2] > 20) {
    	clearTimer(timer2);
    	writeDebugStreamLine("FL=%d FR=%d LS=%d RS=%d BR=%d front=%d left=%d",
    	  SensorValue[FrontLeft], SensorValue[FrontRight],
    	  SensorValue[LeftSide], SensorValue[RightSide],
    	  SensorValue[BottomRear], front_distance, left_distance);
    }

		char status[32];
		snprintf(status, sizeof(status)-1,
		  "%-3d %-03d %-3d", SensorValue[FrontLeft], front_distance, SensorValue[FrontRight]);
		clearLCDLine(0);
    displayLCDCenteredString(0, status);

		snprintf(status, sizeof(status)-1,
		  "%-3d %-3d %-3d", SensorValue[LeftSide], SensorValue[BottomRear], SensorValue[RightSide]);
		clearLCDLine(1);
    displayLCDCenteredString(1, status);
		wait1Msec(100);
	}
}

int cap(int value) {
  if (value < 0) return 300;
  if (value > 300) return 300;
  return value;
}

task measure() {
	while (true) {
    int l = cap(SensorValue[FrontLeft]);
    int r = cap(SensorValue[FrontRight]);

	  front_sum += l < r ? l : r;
	  left_sum += cap(SensorValue[LeftSide]);

	  count++;

    if (time1[timer3] < 100) {
  	  wait1Msec(1);
  	  continue;
    }

    clearTimer(timer3);

    front_distance = front_sum / count;
    left_distance = left_sum / count;

    front_sum = 0;
    left_sum = 0;
    count = 0;
  }
}

void forward(int left, int right) {
	motor[LF] = left;
	motor[LR] = left;
	motor[RF] = right;
	motor[RR] = right;
}


task main()
{
	startTask(display);
  startTask(measure);

  State state = FORWARD;
	while (true) {
		switch (state) {
		case FORWARD: {
		  int p = 127;
		  if (front_distance < 127) p = front_distance < 30 ? 30 : front_distance;

		  forward(p, p);

			if (front_distance < 20) {
				state = ROTATE;
				break;
			}
			break;
    }
		case ROTATE:
			forward(50, -50);
			if (left_distance < 20) state = FORWARD;
			break;
		}
	}
}
